<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Explanations"><meta name="keywords" content="rust, rustlang, rust-lang, _03_explanations"><title>egg::tutorials::_03_explanations - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../egg/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../egg/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Module _03_explanations</a></h2><div class="sidebar-elems"><div id="sidebar-vars" data-name="_03_explanations" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../egg/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Module <a href="../../index.html">egg</a>::<wbr><a href="../index.html">tutorials</a>::<wbr><a class="mod" href="#">_03_explanations</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../src/egg/tutorials/_03_explanations.rs.html#2-133">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="explanations"><a href="#explanations">Explanations</a></h2>
<p>It’s often useful to know exactly why two terms are equivalent in
the egraph.
For example, if you are trying to debug incorrect rules,
it would be useful to have a trace of rewrites showing how an example
given bad equivalence was found.
<code>egg</code> uses an algorithm adapted from
<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.76.1716&amp;rep=rep1&amp;type=pdf">Proof-Producing Congruence Closure</a>
in order to generate such <a href="../../struct.Explanation.html"><code>Explanation</code></a>s between two given terms.</p>
<p>Consider this program, which prints a <a href="../../type.FlatExplanation.html"><code>FlatExplanation</code></a> showing how
<code>(/ (* (/ 2 3) (/ 3 2)) 1)</code> can be simplified to <code>1</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">egg</span>::{<span class="kw-2">*</span>, <span class="ident">rewrite</span> <span class="kw">as</span> <span class="ident">rw</span>};
<span class="kw">let</span> <span class="ident">rules</span>: <span class="kw-2">&amp;</span>[<span class="ident">Rewrite</span><span class="op">&lt;</span><span class="ident">SymbolLang</span>, ()<span class="op">&gt;</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[
    <span class="macro">rw!</span>(<span class="string">&quot;div-one&quot;</span>; <span class="string">&quot;?x&quot;</span> =&gt; <span class="string">&quot;(/ ?x 1)&quot;</span>),
    <span class="macro">rw!</span>(<span class="string">&quot;unsafe-invert-division&quot;</span>; <span class="string">&quot;(/ ?a ?b)&quot;</span> =&gt; <span class="string">&quot;(/ 1 (/ ?b ?a))&quot;</span>),
    <span class="macro">rw!</span>(<span class="string">&quot;simplify-frac&quot;</span>; <span class="string">&quot;(/ ?a (/ ?b ?c))&quot;</span> =&gt; <span class="string">&quot;(/ (* ?a ?c) (* (/ ?b ?c) ?c))&quot;</span>),
    <span class="macro">rw!</span>(<span class="string">&quot;cancel-denominator&quot;</span>; <span class="string">&quot;(* (/ ?a ?b) ?b)&quot;</span> =&gt; <span class="string">&quot;?a&quot;</span>),
    <span class="macro">rw!</span>(<span class="string">&quot;times-zero&quot;</span>; <span class="string">&quot;(* ?a 0)&quot;</span> =&gt; <span class="string">&quot;0&quot;</span>),
];

<span class="kw">let</span> <span class="ident">start</span> <span class="op">=</span> <span class="string">&quot;(/ (* (/ 2 3) (/ 3 2)) 1)&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">end</span> <span class="op">=</span> <span class="string">&quot;1&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">runner</span> <span class="op">=</span> <span class="ident">Runner::default</span>().<span class="ident">with_explanations_enabled</span>().<span class="ident">with_expr</span>(<span class="kw-2">&amp;</span><span class="ident">start</span>).<span class="ident">run</span>(<span class="ident">rules</span>);

<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">runner</span>.<span class="ident">explain_equivalence</span>(<span class="kw-2">&amp;</span><span class="ident">start</span>, <span class="kw-2">&amp;</span><span class="ident">end</span>).<span class="ident">get_flat_string</span>());</code></pre></div>
<p>The output of the program is a series of s-expressions annotated
with the rewrite being performed:</p>
<div class="example-wrap"><pre class="language-text"><code>(/ (* (/ 2 3) (/ 3 2)) 1)
(Rewrite&lt;= div-one (* (/ 2 3) (/ 3 2)))
(* (Rewrite=&gt; unsafe-invert-division (/ 1 (/ 3 2))) (/ 3 2))
(Rewrite=&gt; cancel-denominator 1)</code></pre></div>
<p>At each step, the part of the term being rewritten is annotated
with the rule being applied.
Each term besides the first term has exactly one rewrite annotation.
<code>Rewrite=&gt;</code> indicates that the previous term is rewritten to the current term
and <code>Rewrite&lt;=</code> indicates that the current term is rewritten to the previous term.</p>
<p>It turns out that these rules can easily lead to undesirable results in the egraph.
For example, with just <code>0</code> as the starting term, the egraph finds that <code>0</code> is equivalent
to <code>1</code> within a few iterations.
Here’s the flattened explanation that <code>egg</code> generates:</p>
<div class="example-wrap"><pre class="language-text"><code>0
(Rewrite&lt;= times-zero (* (/ 1 0) 0))
(Rewrite=&gt; cancel-denominator 1)</code></pre></div>
<p>This tells you how the egraph got from <code>0</code> to <code>1</code>, but it’s not clear why.
In fact, normally the rules <code>times-zero</code> and <code>cancel-denominator</code> are perfectly
reasonable.
However, in the presence of a division by zero, they lead to arbitrary unions in the egraph.
So the true problem is the presense of the term <code>(/ 1 0)</code>.
For these kinds of questions, <code>egg</code> provides the <code>explain_existance</code> function which can be used to get an explanation
of why a term exists in the egraph in the first place.</p>
<h2 id="explanation-trees"><a href="#explanation-trees">Explanation Trees</a></h2>
<p>So far we have looked at the <a href="../../type.FlatExplanation.html"><code>FlatExplanation</code></a> represenation of explanations because
they are the most human-readable.
But explanations can also be used for automatic testing or translation validation of egraph results,
so the flat representation is not always necessary.
In fact, the flattened representation misses the opportunity to share parts of the explanation
among several different terms.
Egraphs tend to generate explanations with a large amount of duplication of explanations
from one term to another, making explanation-sharing very important.
To solve this problem, <code>egg</code> provides the <a href="../../type.TreeExplanation.html"><code>TreeExplanation</code></a> representation.</p>
<p>Here’s an example <a href="../../type.TreeExplanation.html"><code>TreeExplanation</code></a> in string form:</p>
<div class="example-wrap"><pre class="language-text"><code>(+ 1 (- a (* (- 2 1) a)))
 (+
    1
    (Explanation
      (- a (* (- 2 1) a))
      (-
        a
        (Explanation
          (* (- 2 1) a)
          (* (Explanation (- 2 1) (Rewrite=&gt; constant_fold 1)) a)
          (Rewrite=&gt; comm-mul (* a 1))
          (Rewrite&lt;= mul-one a)))
      (Rewrite=&gt; cancel-sub 0)))
 (Rewrite=&gt; constant_fold 1)</code></pre></div>
<p>The big difference between <a href="../../type.FlatExplanation.html"><code>FlatExplanation</code></a> and <a href="../../type.TreeExplanation.html"><code>TreeExplanation</code></a> is that now
children of terms can contain explanations themselves.
So a <a href="../../struct.TreeTerm.html"><code>TreeTerm</code></a> can have have each of their children be rewritten from an initial term
to a final term, making the representation more compact.
In addition, the string format supports let bindings in order to allow sharing of explantions:</p>
<div class="example-wrap"><pre class="language-text"><code>(let
  (v_0 (- 2 1))
  (let
    (v_1 (- 2 (Explanation v_0 (Rewrite=&gt; constant_fold 1))))
    (Explanation
      (* (- 2 (- 2 1)) (- 2 (- 2 1)))
      (*
        (Explanation (- 2 (- 2 1)) v_1 (Rewrite=&gt; constant_fold 1))
        (Explanation (- 2 (- 2 1)) v_1 (Rewrite=&gt; constant_fold 1)))
      (Rewrite=&gt; constant_fold 1))))</code></pre></div>
<p>As you can see, the let binding allows for sharing the term <code>v_1</code>.
There are other duplicate expressions that could be let bound, but are not because
<code>egg</code> only binds shared sub-terms found during the explanation generation process.</p>
<p>Besides the string forms, <a href="../../type.TreeExplanation.html"><code>TreeExplanation</code></a> and <a href="../../type.FlatExplanation.html"><code>FlatExplanation</code></a> encode the same information
as Rust objects.
For proof sharing, each <code>Rc&lt;TreeTerm&gt;</code> in the <a href="../../type.TreeExplanation.html"><code>TreeExplanation</code></a> can be checked for pointer
equality with other terms.</p>
</div></details></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="egg" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>